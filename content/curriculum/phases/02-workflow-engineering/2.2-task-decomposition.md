---
id: "2.2-task-decomposition"
title: "Task Decomposition"
phase: 2
module: 2
estimatedMinutes: 10
concepts:
  - task-breakdown
  - atomic-tasks
  - dependencies
  - orchestration
bloomLevel: "apply"
---

# Task Decomposition

## WHY This Matters

AI excels at focused, well-defined tasks. It struggles with ambiguous, multi-part requests. The skill of breaking complex work into AI-manageable chunks is what separates effective operators from frustrated users who complain "AI doesn't understand what I want."

**The decomposition advantage:**
- Higher quality outputs (focused attention)
- Better error isolation (know which step failed)
- Reusable components (build a library of prompts)
- Clearer human oversight (review at checkpoints)

---

## WHAT You Need to Know

### The Atomic Task Principle

:::concept[atomic-task]
An **atomic task** is the smallest unit of work that produces a meaningful, verifiable output. For AI, atomic tasks should:

- Have a single, clear objective
- Require no mid-task decisions
- Produce output that can be verified independently
- Take seconds to minutes, not hours
- Be repeatable with consistent results
:::

**Decomposition example: "Write a marketing campaign"**

❌ **Too big (not atomic):**
> "Create a complete marketing campaign for our product launch"

✅ **Properly decomposed:**
1. Generate 10 campaign theme concepts (brainstorm)
2. Evaluate themes against brand guidelines (analysis)
3. Develop messaging pillars for chosen theme (strategy)
4. Write email subject lines (copy generation)
5. Write email body copy (copy generation)
6. Create social media post variants (adaptation)
7. Generate ad headlines (copy generation)
8. Review all copy for consistency (quality check)

### Dependency Mapping

:::concept[dependencies]
**Dependencies** are relationships between tasks where one must complete before another can start. Types include:

- **Sequential**: Task B needs output from Task A
- **Parallel**: Tasks can run simultaneously
- **Conditional**: Task B only runs if Task A produces specific result
- **Iterative**: Task repeats until condition met
:::

**Dependency visualization:**

```
[Research] → [Outline] → [Draft] → [Edit] → [Final]
     ↓           ↓
[Competitor  [Examples
 Analysis]   Search]
     ↓           ↓
     └─────→ [Synthesize] ─→ [Insert into Draft]
```

### The Orchestration Pattern

Complex workflows often follow this pattern:

```
┌─────────────────────────────────────────────────┐
│                 ORCHESTRATOR                     │
│  (coordinates tasks, manages state, handles      │
│   errors, combines outputs)                      │
└──────────────┬──────────────────────────────────┘
               │
    ┌──────────┼──────────┐
    ↓          ↓          ↓
[Task A]   [Task B]   [Task C]
    ↓          ↓          ↓
[Output A] [Output B] [Output C]
    └──────────┼──────────┘
               ↓
        [Combined Result]
```

**Orchestration responsibilities:**
- Task sequencing and parallel execution
- Passing outputs between tasks
- Error handling and retry logic
- Human checkpoint management
- Final assembly of outputs

### The Decomposition Method

**Step 1: Start with the end**
What's the final deliverable? Work backwards.

**Step 2: Identify natural breaks**
Where would you naturally pause, review, or make a decision?

**Step 3: Define inputs and outputs**
For each chunk, what does it need? What does it produce?

**Step 4: Check atomicity**
Can each chunk be done by AI without asking clarifying questions?

**Step 5: Map dependencies**
Which chunks depend on others? Which can run in parallel?

**Step 6: Add checkpoints**
Where should humans verify before proceeding?

---

## HOW to Apply This

### Exercise: Decompose Complex Tasks

:::exercise[decomposition-practice]
**Decompose each of these tasks into atomic steps:**

**Task 1: Quarterly Business Review Presentation**
Break into steps covering: data gathering, analysis, story creation, slide content, and review.

**Task 2: Customer Complaint Resolution**
Include: understanding the issue, researching history, drafting response, and escalation logic.

**Task 3: Job Posting Creation**
Cover: requirements gathering, competitive analysis, writing, compliance check, and formatting.

**For each decomposition, identify:**
- Input needed for each step
- Output produced by each step
- Dependencies between steps
- Where human checkpoints should be
:::

### Task Decomposition Template

| # | Task Name | Input | Output | Dependencies | Human Checkpoint? |
|---|-----------|-------|--------|--------------|-------------------|
| 1 | | | | None | |
| 2 | | | | Step 1 | |
| 3 | | | | Steps 1, 2 | |
| 4 | | | | Step 3 | ✓ |

### Common Decomposition Patterns

| Complex Task | Decomposition Pattern |
|--------------|----------------------|
| **Research report** | Gather → Filter → Analyze → Outline → Draft → Cite → Review |
| **Content creation** | Brief → Research → Outline → Draft → Edit → Format → Review |
| **Data analysis** | Extract → Clean → Transform → Analyze → Visualize → Narrate |
| **Decision support** | Frame question → Gather options → Evaluate → Pros/cons → Recommend |
| **Communication** | Audience analysis → Key messages → Draft → Tone check → Finalize |

### When to Combine vs. Separate

| Combine When | Separate When |
|--------------|---------------|
| Tasks share context that's expensive to repeat | Tasks might have different quality needs |
| Output of one is trivially small | Mid-point review is valuable |
| Combined takes < 30 seconds | Either task might fail independently |
| No human judgment needed between | Different expertise/models optimal |

### Self-Check

:::checklist[module-2.2-complete]
- [ ] I understand what makes a task "atomic"
- [ ] I can identify dependencies between tasks
- [ ] I can decompose complex work into AI-manageable steps
- [ ] I know where to place human checkpoints
- [ ] I can create a task decomposition template
:::

---

## Up Next

In **Module 2.3: Quality and Iteration**, you'll learn how to build quality assurance into AI workflows—validation, iteration, and feedback loops.
